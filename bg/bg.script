-- Background glow efect can be made with a shader
-- If need to optimize, do it with shader

local camera = require "orthographic.camera"
local tokens = require "tokens.tokens"

-- Use go's instead of tilemap
-- To create some visual efects
-- Like glow on mouse over

-- Index = shape position
-- Positions are same with tilemap
-- Value = sprite url
local url_table = {}

function init(self)
    msg.post(".", "acquire_input_focus")

    -- Create background go's
    for i = -14, 14 do
        url_table[i] = {}

        for n = -8, 8 do
            local bg = factory.create("#bg_factory", vmath.vector3(i * 48, n * 48, -1))
            local url = msg.url(bg)
            url.fragment = "sprite"

            go.set(url, "tint.w", 0.1)

            url_table[i][n] = url
        end
    end
    
    self.mouse_pos = vmath.vector3()
    self.last_tile = vmath.vector3()

    self.profile = false
    self.selected = false
    self.selected_token = msg.url()
end

function on_message(self, message_id, message, sender)
    if message_id == hash("token_placed") then
        go.set(url_table[message.x + 1][message.y], "tint", message.tint)
        go.set(url_table[message.x - 1][message.y], "tint", message.tint)
        go.set(url_table[message.x][message.y + 1], "tint", message.tint)
        go.set(url_table[message.x][message.y - 1], "tint", message.tint)
    end
end

function on_input(self, action_id, action)
    -- Mouse movement action_id == nil
    if action_id == nil then
        self.mouse_pos = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
        self.mouse_pos.x = math.floor((self.mouse_pos.x + 25) / 50)
        self.mouse_pos.y = math.floor((self.mouse_pos.y + 25) / 50)

        -- Mouse out
        go.animate(url_table[self.last_tile.x][self.last_tile.y],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)

        go.animate(url_table[self.last_tile.x + 1][self.last_tile.y],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)
        go.animate(url_table[self.last_tile.x - 1][self.last_tile.y],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)
        go.animate(url_table[self.last_tile.x][self.last_tile.y + 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)
        go.animate(url_table[self.last_tile.x][self.last_tile.y - 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)

        go.animate(url_table[self.last_tile.x + 1][self.last_tile.y + 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)
        go.animate(url_table[self.last_tile.x - 1][self.last_tile.y - 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)
        go.animate(url_table[self.last_tile.x - 1][self.last_tile.y + 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)
        go.animate(url_table[self.last_tile.x + 1][self.last_tile.y - 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.1, go.EASING_LINEAR, 1)

        -- Mouse over
        go.animate(url_table[self.mouse_pos.x][self.mouse_pos.y],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.7, go.EASING_LINEAR, 0.1)

        go.animate(url_table[self.mouse_pos.x + 1][self.mouse_pos.y],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.3, go.EASING_LINEAR, 0.7)
        go.animate(url_table[self.mouse_pos.x - 1][self.mouse_pos.y],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.3, go.EASING_LINEAR, 0.7)
        go.animate(url_table[self.mouse_pos.x][self.mouse_pos.y + 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.3, go.EASING_LINEAR, 0.7)
        go.animate(url_table[self.mouse_pos.x][self.mouse_pos.y - 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.3, go.EASING_LINEAR, 0.7)

        go.animate(url_table[self.mouse_pos.x + 1][self.mouse_pos.y + 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.2, go.EASING_LINEAR, 1)
        go.animate(url_table[self.mouse_pos.x - 1][self.mouse_pos.y - 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.2, go.EASING_LINEAR, 1)
        go.animate(url_table[self.mouse_pos.x - 1][self.mouse_pos.y + 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.2, go.EASING_LINEAR, 1)
        go.animate(url_table[self.mouse_pos.x + 1][self.mouse_pos.y - 1],
            "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.2, go.EASING_LINEAR, 1)

        self.last_tile = self.mouse_pos

        -- If a token selected to place
        if self.selected then
            -- 48 coz reasons unknown
            local world_pos = vmath.vector3(self.mouse_pos)
            world_pos.x = world_pos.x * 48
            world_pos.y = world_pos.y * 48

            go.set_position(world_pos, self.selected_token)
        end

    -- Place the token
    elseif action_id == hash("touch") and action.pressed and self.selected then
        if tokens.is_free(self.mouse_pos.x, self.mouse_pos.y) then
            local script_url = msg.url(self.selected_token)
            script_url.fragment = "script"

            msg.post(script_url, "placed")

            self.selected = false
        end

    elseif action_id == hash("profile") and action.pressed then
        self.profile = not self.profile
        profiler.enable_ui(self.profile)

    -- Press place input to activate place mod. For testing
    elseif action_id == hash("place") and action.pressed and not self.selected then
        self.selected_token = factory.create("#token_factory")
        self.selected = true
    end
end